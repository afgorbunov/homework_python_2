# -*- coding:utf-8 -*-

# Практическая работа

#     1. Каждое из слов «разработка», «сокет», «декоратор» представить в
# строковом формате и проверить тип и содержание соответствующих переменных.
# Затем с помощью онлайн-конвертера преобразовать строковые представление в
# формат Unicode и также проверить тип и содержимое переменных.
#     2. Каждое из слов «class», «function», «method» записать в байтовом
# типе без преобразования в последовательность кодов (не используя методы
# encode и decode) и определить тип, содержимое и длину соответствующих
# переменных.
#     3. Определить, какие из слов «attribute», «класс», «функция», «type»
# невозможно записать в байтовом типе.
#     4. Преобразовать слова «разработка», «администрирование», «protocol»,
# «standard» из строкового представления в байтовое и выполнить обратное
# преобразование (используя методы encode и decode).
#     5. Выполнить пинг веб-ресурсов yandex.ru, youtube.com и преобразовать
# результаты из байтовового в строковый тип на кириллице.
#     6. Создать текстовый файл test_file.txt, заполнить его тремя строками:
# «сетевое программирование», «сокет», «декоратор». Проверить кодировку файла
# по умолчанию. Принудительно открыть файл в формате Unicode и вывести его
# содержимое.

# Необходимые и достаточные условия

#     1. Реализовать приведение строк "разработка", "сокет", "декоратор" к
# типу bytes используя нативные методы строк;
#     2. Реализовать приведение полученных экземпляров типа bytes к типу str;
#     3. Реализовать приведение полученных строк и байтовых
# последовательностей с использование различных кодировок utf-8 latin-1.


def task_1():
    print(' Задача 1 '.center(79, '='))
    words = {
        'разработка': b'\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430',
        'сокет': b'\u0441\u043e\u043a\u0435\u0442',
        'декоратор': b'\u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440',
    }
    for w, b in words.items():
        print(
            f'Слово: {w}\n\tтип: {type(w)}\n\tбайтовое: {b}\n\tтип байтового: {type(b)}')


def task_2():
    print(' Задача 2 '.center(79, '='))
    words = [b'class', b'function', b'method']
    for w in words:
        print(f'Слово: {w}\n\tтип: {type(w)}\n\tдлинна:{len(w)}')


def task_3():
    print(' Задача 3 '.center(79, '='))
    print(
        'В байтовом виде невозможно записать слова, состоящие из символов, '
        'не входящих в набор ACSII. Таким образом, из слов «attribute», '
        '«класс», «функция», «type» в байтовом виде не смогут быть '
        'представлены кирилические слова: «класс», «функция».'
    )


def task_4():
    print(' Задача 4 '.center(79, '='))
    words = ['разработка', 'администрирование', 'protocol', 'standard']
    bwords = [w.encode() for w in words]
    for i in range(len(words)):
        print(
            f'Слово: {words[i]}\n\tбайтовое: {bwords[i]}\n\tпреобразованное: {bwords[i].decode()}')


if __name__ == '__main__':
    task_1()
    task_2()
    task_3()
    task_4()
